export type NewsItem = {
  id: number
  title: string
  href: string
  date?: string
  image?: string
  excerpt?: string
}

export type NewsPage = {
  items: NewsItem[]
  page: number
  hasPrev: boolean
  hasNext: boolean
  totalPages: number
}

export type NewsDetail = {
  id: number
  title: string
  date?: string
  subtitle?: string
  paragraphs?: string[]
  images?: string[]
  embeds?: string[]
  links?: { href: string; text: string }[]
  contentHtml: string
}

export type SectionDetail = {
  title: string
  content: string
  lastUpdated: string
  originalUrl: string
}

// –ù–æ–≤—ã–µ —Ç–∏–ø—ã –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
export type ContentElement = 
  | { type: 'html'; content: string }
  | { type: 'table'; headers: string[]; data: string[][] }
  | { type: 'news'; items: NewsItem[] }

export type StructuredSectionDetail = {
  title: string
  banner?: {
    src: string
    alt?: string
  }
  content: ContentElement[]
  lastUpdated: string
  originalUrl: string
}

const BASE = "https://vilely-immortal-damselfly.cloudpub.ru/rksi"
const ORIGIN = "https://vilely-immortal-damselfly.cloudpub.ru/rksi"

function normalizeUrl(url?: string | null): string | undefined {
  if (!url) return undefined
  if (url.startsWith("http")) return url
  if (url.startsWith("//")) return `${ORIGIN}${url.replace('//', '/')}`
  if (url.startsWith("/")) return `${ORIGIN}${url}`
  return `${ORIGIN}/${url}`
}

async function fetchWithTimeout(resource: string, options?: RequestInit & { timeoutMs?: number }) {
  const { timeoutMs = 15000, ...init } = options || {}
  const controller = new AbortController()
  const id = setTimeout(() => controller.abort(), timeoutMs)
  try {
    const res = await fetch(resource, { 
         ...init, 
         signal: controller.signal 
        })
    return res
  } finally {
    clearTimeout(id)
  }
}

export class RksiApi {
  static async getNews(page: number = 1): Promise<NewsPage> {
    const cacheKey = `news:page:${page}`
    const cached = sessionStorage.getItem(cacheKey)
    if (cached) {
      try {
        const parsed = JSON.parse(cached) as NewsPage & { timestamp: number }
        // –ö—ç—à –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 5 –º–∏–Ω—É—Ç
        if (Date.now() - parsed.timestamp < 5 * 60 * 1000) {
          console.info(`üóÑÔ∏è [RksiApi.getNews] cache hit for page=${page}. items=${parsed.items.length}`)
          return parsed
        }
      } catch {}
    }
    console.info(`üåê [RksiApi.getNews] fetching page=${page} ‚Üí ${BASE}/news/${page}`)
    const res = await fetchWithTimeout(`${BASE}/news/${page}`, { timeoutMs: 15000 })
    console.info(`üì• [RksiApi.getNews] status=${res.status}`)
    const html = await res.text()
    const doc = new DOMParser().parseFromString(html, "text/html")

    console.info(`üì• [RksiApi.getNews] ${doc.body.innerHTML}`)

    const items: NewsItem[] = []
    // –¢–æ—á–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∫–∞—Ä—Ç–æ—á–µ–∫: .flexnews
    const candidates = doc.querySelectorAll<HTMLElement>(".flexnews")
    console.info(`üß© [RksiApi.getNews] .flexnews found=${candidates.length}`)
    candidates.forEach((el, idx) => {
      const link = el.querySelector<HTMLAnchorElement>("a[href*='/news/n_']")
      if (!link) return
      const rawHref = link.getAttribute("href") || ""
      const hrefPath = rawHref.startsWith("http") ? rawHref : new URL(rawHref, ORIGIN).pathname
      const idMatch = hrefPath.match(/n_(\d+)/)
      const id = idMatch ? Number(idMatch[1]) : NaN
      if (!id) return

      const title = (el.querySelector("h4")?.textContent || link.textContent || "").trim()
      const date = (el.querySelector(".smalli")?.textContent || "").trim()
      const img = normalizeUrl(el.querySelector<HTMLImageElement>("img")?.getAttribute("src"))

      // –û–ø–∏—Å–∞–Ω–∏–µ: –≤–æ–∑—å–º—ë–º —Ç–µ–∫—Å—Ç –≤—Ç–æ—Ä–æ–≥–æ –¥–∏–≤-–∞ –≤–Ω—É—Ç—Ä–∏ .flexnews
      let excerpt = ""
      const blocks = el.querySelectorAll<HTMLElement>(":scope > div")
      if (blocks.length > 0) {
        const contentDiv = blocks[blocks.length - 1]
        // –£–±–µ—Ä—ë–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –∏ —Å—Å—ã–ª–∫–∏ more
        contentDiv.querySelectorAll("h4, a, span.smalli, br").forEach((n) => n.remove())
        excerpt = (contentDiv.textContent || "").replace(/\s+/g, " ").trim()
      }

      const item: NewsItem = { id, title, href: hrefPath, date, image: img, excerpt }
      items.push(item)
      console.debug(`üì∞ [RksiApi.getNews] item#${idx}:`, item)
    })

    // –û–ø—Ä–µ–¥–µ–ª–∏–º –Ω–∞–ª–∏—á–∏–µ —Å—Ç—Ä–∞–Ω–∏—Ü –Ω–∞–∑–∞–¥/–≤–ø–µ—Ä—ë–¥ (best effort)
    const pagination = doc.querySelector(".pagination, nav[aria-label='pagination'], .pager, .pages")
    const relPrev = pagination?.querySelector("a[rel='prev']") as HTMLAnchorElement | null
    const relNext = pagination?.querySelector("a[rel='next']") as HTMLAnchorElement | null
    const hasPrev = !!relPrev || page > 1
    const hasNext = !!relNext || items.length > 0

    // –û–ø—Ä–µ–¥–µ–ª–∏–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü –∏–∑ navigation
    let totalPages = page
    const navigationText = doc.querySelector("main p")?.textContent || ""
    console.info(`üß≠ [RksiApi.getNews] navigation text: "${navigationText}"`)
    
    // –ò—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –Ω–æ–º–µ—Ä —Å—Ç—Ä–∞–Ω–∏—Ü—ã –≤ navigation
    const pageMatches = navigationText.match(/(\d+)(?=\s*$)/)
    if (pageMatches) {
      totalPages = Number(pageMatches[1])
      console.info(`üß≠ [RksiApi.getNews] found totalPages=${totalPages} from navigation`)
    } else {
      // Fallback: –µ—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ navigation, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â—É—é –ª–æ–≥–∏–∫—É
      if (hasNext) {
        totalPages = page + 1
      }
    }

    const payload: NewsPage & { timestamp: number } = { 
      items, 
      page, 
      hasPrev, 
      hasNext, 
      totalPages,
      timestamp: Date.now()
    }
    console.info(`‚úÖ [RksiApi.getNews] parsed items=${items.length} hasPrev=${hasPrev} hasNext=${hasNext} totalPages=${totalPages}`)
    try { sessionStorage.setItem(cacheKey, JSON.stringify(payload)) } catch {}
    return payload
  }

  static async getNewsDetail(id: number): Promise<NewsDetail> {
    const cacheKey = `news:detail:${id}`
    const cached = sessionStorage.getItem(cacheKey)
    if (cached) {
      try {
        const parsed = JSON.parse(cached) as NewsDetail & { timestamp: number }
        // –ö—ç—à –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 10 –º–∏–Ω—É—Ç –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        if (Date.now() - parsed.timestamp < 10 * 60 * 1000) {
          console.info(`üóÑÔ∏è [RksiApi.getNewsDetail] cache hit for id=${id}`)
          return parsed
        }
      } catch {}
    }
    console.info(`üåê [RksiApi.getNewsDetail] fetching id=${id} ‚Üí ${BASE}/news/n_${id}`)
    const res = await fetchWithTimeout(`${BASE}/news/n_${id}`, { timeoutMs: 15000 })
    console.info(`üì• [RksiApi.getNewsDetail] status=${res.status}`)
    const html = await res.text()
    const doc = new DOMParser().parseFromString(html, "text/html")

    // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∏ –¥–∞—Ç–∞ –≤ <h1> –≤ —Ñ–æ—Ä–º–∞—Ç–µ: "Title [dd.mm.yyyy]"
    const h1Raw = (doc.querySelector("h1")?.textContent || "–ù–æ–≤–æ—Å—Ç—å").trim()
    const m = h1Raw.match(/^(.*)\[(.*)\]\s*$/)
    const title = m ? m[1].trim() : h1Raw
    const date = m ? m[2].trim() : undefined

    // –í–æ–∑—å–º—ë–º –æ—Å–Ω–æ–≤–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
    const mainEl = doc.querySelector("main") || doc.body
    // –£–±–µ—Ä—ë–º —Å–∫—Ä–∏–ø—Ç—ã/–ª–∏—à–Ω–µ–µ
    mainEl.querySelectorAll("script, style, nav, header, footer").forEach((n) => n.remove())
    // –ü–æ–¥–∑–∞–≥–æ–ª–æ–≤–æ–∫ ‚Äî –ø–µ—Ä–≤—ã–π <b> –≤ main
    const subtitle = mainEl.querySelector("b")?.textContent?.trim()
    // –ü–∞—Ä–∞–≥—Ä–∞—Ñ—ã ‚Äî –≤—Å–µ <p>, –Ω–µ —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ <img>
    const paragraphs = Array.from(mainEl.querySelectorAll<HTMLParagraphElement>("p, li")).filter(p => !p.querySelector("img")).map(p => p.textContent?.trim() || "").filter(Boolean)
    // –ö–∞—Ä—Ç–∏–Ω–∫–∏ ‚Äî –≤–Ω—É—Ç—Ä–∏ .img50
    const images = Array.from(mainEl.querySelectorAll<HTMLImageElement>(".img50 img")).map(img => normalizeUrl(img.getAttribute("src"))!).filter(Boolean)
    // –í–∏–¥–µ–æ–≤—Å—Ç–∞–≤–∫–∏/iframes ‚Äî —Å–æ–±–µ—Ä—ë–º –ª—é–±—ã–µ iframe –≤ main
    const embeds = Array.from(mainEl.querySelectorAll<HTMLIFrameElement>("iframe")).map(f => normalizeUrl(f.getAttribute("src")) || "").filter(Boolean)
    // –°—Å—ã–ª–∫–∏ –≤–Ω–∏–∑—É ‚Äî –ª—é–±—ã–µ <a> –≤ main (–æ—Å—Ç–∞–≤–∏–º —Ç–æ–ª—å–∫–æ –≤–Ω–µ—à–Ω–∏–µ/–∞–±—Å–æ–ª—é—Ç–Ω—ã–µ)
    const links = Array.from(mainEl.querySelectorAll<HTMLAnchorElement>("a")).map(a => ({
      href: normalizeUrl(a.getAttribute("href")) || "",
      text: (a.textContent || "").trim()
    })).filter(l => !!l.href)

    // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤ –≤ HTML
    mainEl.querySelectorAll<HTMLImageElement>("img").forEach((img) => {
      const src = img.getAttribute("src")
      const normalized = normalizeUrl(src)
      if (normalized) img.setAttribute("src", normalized)
    })
    mainEl.querySelectorAll<HTMLAnchorElement>("a").forEach((a) => {
      const href = a.getAttribute("href")
      const normalized = normalizeUrl(href)
      if (normalized) a.setAttribute("href", normalized)
    })
    const contentHtml = mainEl.innerHTML

    const payload: NewsDetail & { timestamp: number } = { 
      id, 
      title, 
      date, 
      subtitle, 
      paragraphs, 
      images, 
      embeds, 
      links, 
      contentHtml,
      timestamp: Date.now()
    }
    console.info(`‚úÖ [RksiApi.getNewsDetail] parsed id=${id} title="${title}"`)
    try { sessionStorage.setItem(cacheKey, JSON.stringify(payload)) } catch {}
    return payload
  }

  static prefetchNewsPages(currentPage: number, hasPrev: boolean, hasNext: boolean) {
    if (hasPrev) this.getNews(currentPage - 1).catch((e) => console.warn(`‚ö†Ô∏è prefetch prev failed:`, e))
    if (hasNext) this.getNews(currentPage + 1).catch((e) => console.warn(`‚ö†Ô∏è prefetch next failed:`, e))
  }

  static async getSectionDetail(path: string): Promise<StructuredSectionDetail> {
    const cacheKey = `section:${path}`
    const cached = sessionStorage.getItem(cacheKey)
    if (cached) {
      try {
        const parsed = JSON.parse(cached) as StructuredSectionDetail & { timestamp: number }
        // –ö—ç—à –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 1 —á–∞—Å –¥–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü –ø–æ–¥—Ä–∞–∑–¥–µ–ª–æ–≤
        if (Date.now() - parsed.timestamp < 60 * 60 * 1000) {
          console.info(`üóÑÔ∏è [RksiApi.getSectionDetail] cache hit for path=${path}`)
          return parsed
        }
      } catch {
        // –ï—Å–ª–∏ –∫—ç—à –ø–æ–≤—Ä–µ–∂–¥–µ–Ω, —É–¥–∞–ª—è–µ–º –µ–≥–æ
        sessionStorage.removeItem(cacheKey)
      }
    }

    console.info(`üåê [RksiApi.getSectionDetail] fetching path=${path} ‚Üí ${BASE}/${path}`)
    const res = await fetchWithTimeout(`${BASE}/${path}`, { timeoutMs: 15000 })
    console.info(`üì• [RksiApi.getSectionDetail] status=${res.status}`)
    
    if (!res.ok) {
      throw new Error(`HTTP error! status: ${res.status}`)
    }

    const html = await res.text()
    const doc = new DOMParser().parseFromString(html, "text/html")

    // –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ç–µ–≥–∞ main
    const mainElement = doc.querySelector("main")
    const titleElement = doc.querySelector("title") || doc.querySelector("h1")
    
    if (!mainElement) {
      throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã. –í–æ–∑–º–æ–∂–Ω–æ, —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –∏–º–µ–µ—Ç –¥—Ä—É–≥—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É.')
    }

    // –ò—â–µ–º –±–∞–Ω–Ω–µ—Ä (—ç–ª–µ–º–µ–Ω—Ç —Å –∫–ª–∞—Å—Å–æ–º h1 –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –≤–Ω—É—Ç—Ä–∏)
    let banner: { src: string; alt?: string } | undefined
    const bannerElement = doc.querySelector('.h1 img')
    if (bannerElement) {
      const img = bannerElement as HTMLImageElement
      banner = {
        src: normalizeUrl(img.getAttribute('src')) || img.src,
        alt: img.alt || undefined
      }
    }

    // –ü–∞—Ä—Å–∏–º HTML –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    let structuredContent: ContentElement[]
    try {
      structuredContent = this.parseHtmlToStructuredContent(mainElement)
    } catch (error) {
      console.warn('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ HTML, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback:', error)
      // Fallback: –µ—Å–ª–∏ –ø–∞—Ä—Å–∏–Ω–≥ –Ω–µ —É–¥–∞–ª—Å—è, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º HTML
      structuredContent = [{
        type: 'html',
        content: mainElement.innerHTML
      }]
    }
    
    const payload: StructuredSectionDetail & { timestamp: number } = {
      title: titleElement?.textContent?.trim() || `–°—Ç—Ä–∞–Ω–∏—Ü–∞: ${path}`,
      banner,
      content: structuredContent,
      lastUpdated: new Date().toISOString(),
      originalUrl: `https://rksi.ru/${path}`,
      timestamp: Date.now()
    }

    console.info(`‚úÖ [RksiApi.getSectionDetail] parsed path=${path} title="${payload.title}" elements=${structuredContent.length}`)
    try { sessionStorage.setItem(cacheKey, JSON.stringify(payload)) } catch {}
    return payload
  }



  private static parseHtmlToStructuredContent(mainElement: Element): ContentElement[] {
    const elements: ContentElement[] = []
    
    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–≥–æ –æ–±—Ö–æ–¥–∞ –∏ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞
    const processNode = (node: Node): void => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node as Element
        const tagName = element.tagName.toLowerCase()
        const className = element.getAttribute('class') || ''
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ flexbox —Å –Ω–æ–≤–æ—Å—Ç—è–º–∏
        if (className.includes('flexbox')) {
          const newsElements = element.querySelectorAll('.flexnews')
          if (newsElements.length > 0) {
            const newsItems: NewsItem[] = []
            newsElements.forEach((el) => {
              const link = el.querySelector<HTMLAnchorElement>("a[href*='/news/n_']")
              if (!link) return
              const rawHref = link.getAttribute("href") || ""
              const hrefPath = rawHref.startsWith("http") ? rawHref : new URL(rawHref, ORIGIN).pathname
              const idMatch = hrefPath.match(/n_(\d+)/)
              const id = idMatch ? Number(idMatch[1]) : NaN
              if (!id) return

              const title = (el.querySelector("h4")?.textContent || link.textContent || "").trim()
              const date = (el.querySelector(".smalli")?.textContent || "").trim()
              const img = normalizeUrl(el.querySelector<HTMLImageElement>("img")?.getAttribute("src"))

              let excerpt = ""
              const blocks = el.querySelectorAll<HTMLElement>(":scope > div")
              if (blocks.length > 0) {
                const contentDiv = blocks[blocks.length - 1]
                contentDiv.querySelectorAll("h4, a, span.smalli, br").forEach((n) => n.remove())
                excerpt = (contentDiv.textContent || "").replace(/\s+/g, " ").trim()
              }

              newsItems.push({ id, title, href: hrefPath, date, image: img, excerpt })
            })
            
            if (newsItems.length > 0) {
              elements.push({ type: 'news', items: newsItems })
              return // –ù–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–æ—á–µ—Ä–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã —ç—Ç–æ–≥–æ —É–∑–ª–∞
            }
          }
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ —Ç–∞–±–ª–∏—Ü—ã
        if (tagName === 'table') {
          const tableData = this.parseTable(element as HTMLTableElement)
          if (tableData) {
            elements.push(tableData)
            return // –ù–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–æ—á–µ—Ä–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã —ç—Ç–æ–≥–æ —É–∑–ª–∞
          }
        }
        
        // –î–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–æ—á–µ—Ä–Ω–∏–µ —É–∑–ª—ã
        Array.from(element.childNodes).forEach(processNode)
      }
    }
    
    // –°–æ–±–∏—Ä–∞–µ–º HTML –∫–æ–Ω—Ç–µ–Ω—Ç –º–µ–∂–¥—É —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–º–∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏
    const collectHtmlContent = (): void => {
      let currentHtml = ''
      
      const walkNodes = (node: Node): void => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          const element = node as Element
          const tagName = element.tagName.toLowerCase()
          const className = element.getAttribute('class') || ''
          
          // –ï—Å–ª–∏ —ç—Ç–æ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω—ã–π HTML –∏ –¥–æ–±–∞–≤–ª—è–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
          if (className.includes('flexbox') || tagName === 'table') {
            if (currentHtml.trim()) {
              elements.push({ type: 'html', content: currentHtml.trim() })
              currentHtml = ''
            }
            
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
            if (className.includes('flexbox')) {
              const newsElements = element.querySelectorAll('.flexnews')
              if (newsElements.length > 0) {
                const newsItems: NewsItem[] = []
                newsElements.forEach((el) => {
                  const link = el.querySelector<HTMLAnchorElement>("a[href*='/news/n_']")
                  if (!link) return
                  const rawHref = link.getAttribute("href") || ""
                  const hrefPath = rawHref.startsWith("http") ? rawHref : new URL(rawHref, ORIGIN).pathname
                  const idMatch = hrefPath.match(/n_(\d+)/)
                  const id = idMatch ? Number(idMatch[1]) : NaN
                  if (!id) return

                  const title = (el.querySelector("h4")?.textContent || link.textContent || "").trim()
                  const date = (el.querySelector(".smalli")?.textContent || "").trim()
                  const img = normalizeUrl(el.querySelector<HTMLImageElement>("img")?.getAttribute("src"))

                  let excerpt = ""
                  const blocks = el.querySelectorAll<HTMLElement>(":scope > div")
                  if (blocks.length > 0) {
                    const contentDiv = blocks[blocks.length - 1]
                    contentDiv.querySelectorAll("h4, a, span.smalli, br").forEach((n) => n.remove())
                    excerpt = (contentDiv.textContent || "").replace(/\s+/g, " ").trim()
                  }

                  newsItems.push({ id, title, href: hrefPath, date, image: img, excerpt })
                })
                
                if (newsItems.length > 0) {
                  elements.push({ type: 'news', items: newsItems })
                  return
                }
              }
            }
            
            if (tagName === 'table') {
              const tableData = this.parseTable(element as HTMLTableElement)
              if (tableData) {
                elements.push(tableData)
                return
              }
            }
          }
          
          // –î–ª—è –æ–±—ã—á–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–æ–±–∞–≤–ª—è–µ–º –∏—Ö HTML –∫ –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω–æ–º—É –∫–æ–Ω—Ç–µ–Ω—Ç—É
          currentHtml += element.outerHTML
        } else if (node.nodeType === Node.TEXT_NODE) {
          // –¢–µ–∫—Å—Ç–æ–≤—ã–µ —É–∑–ª—ã –¥–æ–±–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
          const text = node.textContent || ''
          if (text.trim()) {
            currentHtml += text
          }
        }
      }
      
      // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º –¥–æ—á–µ—Ä–Ω–∏–º —É–∑–ª–∞–º main —ç–ª–µ–º–µ–Ω—Ç–∞
      Array.from(mainElement.childNodes).forEach(walkNodes)
      
      // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–π—Å—è HTML –∫–æ–Ω—Ç–µ–Ω—Ç
      if (currentHtml.trim()) {
        elements.push({ type: 'html', content: currentHtml.trim() })
      }
    }
    
    collectHtmlContent()
    
    return elements
  }

  private static parseTable(tableElement: HTMLTableElement): ContentElement | null {
    const rows = Array.from(tableElement.querySelectorAll('tr'))
    if (rows.length === 0) return null
    
    const data: string[][] = []
    let headers: string[] | undefined
    
    rows.forEach((row, rowIndex) => {
      const cells = Array.from(row.querySelectorAll('td, th')).map(cell => {
        // –û—á–∏—â–∞–µ–º —Ç–µ–∫—Å—Ç –æ—Ç –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –ø–µ—Ä–µ–Ω–æ—Å–æ–≤ —Å—Ç—Ä–æ–∫
        let text = cell.textContent || ''
        text = text.replace(/\s+/g, ' ').trim()
        return text
      })
      
      if (rowIndex === 0) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–∏
        const hasTh = row.querySelector('th')
        if (hasTh || cells.some(cell => cell.length > 0)) {
          headers = cells
        } else {
          // –ï—Å–ª–∏ –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –ø—É—Å—Ç–∞—è, —Å—á–∏—Ç–∞–µ–º –µ—ë –¥–∞–Ω–Ω—ã–º–∏
          data.push(cells)
        }
      } else {
        // –§–∏–ª—å—Ç—Ä—É–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
        if (cells.some(cell => cell.length > 0)) {
          data.push(cells)
        }
      }
    })
    
    // –ï—Å–ª–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, —Å–æ–∑–¥–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ
    if (!headers && data.length > 0) {
      const maxCols = Math.max(...data.map(row => row.length))
      headers = Array.from({ length: maxCols }, (_, i) => `–ö–æ–ª–æ–Ω–∫–∞ ${i + 1}`)
    }
    
    // –§–∏–ª—å—Ç—Ä—É–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–ª–æ–Ω–æ–∫
    const filteredData = data
      .filter(row => row.some(cell => cell.length > 0))
      .map(row => {
        const maxCols = Math.max(...data.map(r => r.length))
        while (row.length < maxCols) {
          row.push('')
        }
        return row
      })
    
    return {
      type: 'table',
      headers: headers || [],
      data: filteredData
    }
  }


}



